/* file_parser.cc
Team New Mexico
prog1
CS530, Spring 2014
*/
 
#include"file_parser.h"
 
#define DEBUG 0
#define DEBUG_NEW 0
/*REM_APOS enable or diable removing apostrophe '*/
#define REM_APOS 0
 
using namespace std;
 
// int file_size;
// vector<line_data> v;
// vector<string> read_v;
 
file_parser::file_parser(string name)
{
    read_v.reserve(500);
    filename = name;
}
 
 
file_parser::~file_parser()
{
}
 
 
void file_parser::read_file()
{
    ifstream infile;
    infile.open(filename.c_str(), ios::in);
    string line;
    if (!infile)
    {
        throw file_parse_exception(filename +" does not exist");
    }
 
    while (getline(infile,line))
    {
        read_v.push_back(line);
    }
    infile.close();
    file_size = read_v.size();
    v.reserve(file_size);
    int linecounter = 0;
    bool donewithline;
    line_data tempdata;
    int column = 0;
    while (linecounter < file_size)
    {
        column = 0;
        donewithline = false;
        line = read_v[linecounter];
        is_apostrophe(line);
        /*
        Nested if statements are messy
        line.empty() is required for everything to work
        */
        tempdata.label="";
        tempdata.opcode="";
        tempdata.operand="";
        tempdata.comment="";
        if (is_comment(line))
        {
            donewithline = true;
            tempdata.comment=line;
        }
        while (!donewithline)
        {
            /*First thing to check is if this column
            is the start of a comment*/
            if (is_comment(line))
            {
                tempdata.comment=line;
                donewithline = true;
            }
            else
            {
                /*error_alert starts as true and if no if
                statemsments are true then error must have occured*/
                bool error_alert = true;
                /*Test if there is a label*/
                if (is_label(line) && (column == 0))
                {
                    string tmpline;
                    tmpline=token(line);
                    int i = 8;
                    while (tmpline[i] != '\0')
                    {
                        tmpline[i] = ' ';
                        i++;
                    }
                    tempdata.label = tmpline;
                    error_alert = false;
                }
                /*Test to see if lable is empty*/
                if (column == 0 && isspace(line[0]))
                {
                    error_alert = false;
                }
                /*Test for opcode*/
                if (is_opcode(line) && (column == 1))
                {
                    tempdata.opcode=token(line);
                    error_alert = false;
                }
                /*Test for operand*/
                if (is_operand(line) && (column == 2))
                {
                    tempdata.operand=token(line);
                    error_alert = false;
                }
                /*Test for blank comment section*/
                if (line.empty())
                {
                    donewithline = true;
                    error_alert = false;
                }
                if (error_alert)
                {
                    throw file_parse_exception("Invalid error has occured on line: "+
                                               int_to_string(++linecounter) + " in column: "
                                               + int_to_string(column));
                }
            }
            column++;
            line = next_token(line);
        }
       
        v.push_back(tempdata);
        linecounter++;
    }
}
 
 
string file_parser::token(string line)
{
    string tmptoken= "";
    unsigned int i = 0;
 
    while (i<line.length()&&!isspace(line[i]))
    {
        /*apostrophe \' detection*/
        if (line[i] == '\'')
        {
            /*Remove i++ below to let ' be included with 'something'*/
            if (REM_APOS)
            {
                i++;
            }
            /**/
            tmptoken += line[i];
            i++;
            while (i<line.length()&&(line[i] != '\''))
            {
                tmptoken += line[i];
                if (DEBUG)
                {
                    cout<<int_to_string(i)<<endl;
                }
                i++;
            }
        }
        else
        {
            tmptoken += line[i];
            i++;
        }
    }
 
    if (DEBUG)
    {
        cout<<"Current Token: "<<tmptoken<<endl;
    }
 
    return tmptoken;
}
 
 
string file_parser::next_token(string line)
{
    bool hit_whitespace = false;
    string newline;
    unsigned int i=0;
    if (DEBUG)
    {
        cout<<"next_token function: " <<
            line<<endl;
    }
 
    while (i<line.length() && !isspace(line[i]))
    {
        /*When searching for next token need to ignore anytthing
        in apostrophe once it reaches the correct stage*/
        if (line[i] == '\'')
        {
            i++;
            while (i<line.length()&&(line[i] != '\''))
            {
                if (DEBUG)
                {
                    cout<<int_to_string(i)<<endl;
                }
                i++;
            }
        }
        else
        {
            i++;
        }
    }
    while (i<line.length() && isspace(line[i]))
    {
        hit_whitespace = true;
        i++;
    }
    while (i<line.size())
    {
        /*When searching for next token need to ignore anytthing
        in apostrophe once it reaches the correct stage*/
        if (line[i] == '\'' && !hit_whitespace)
        {
            i++;
            while (i<line.length()&&(line[i] != '\''))
            {
                if (DEBUG)
                {
                    cout<<int_to_string(i)<<endl;
                }
                i++;
            }
        }
        else
        {
            newline+= line[i];
            i++;
        }
    }
    if (DEBUG)
    {
        cout<< "Working: " << newline << endl;
    }
    return newline;
}
 
 
bool file_parser::is_label(string line)
{
    int i = 0;
    /*Need to check if first character is a letter*/
    if (!(isalpha(line[0])))
    {
        return false;
    }
 
    while (!isspace(line[i]))
    {
        if (!(isdigit(line[i]) || isalpha(line[i])))
        {
            return false;
        }
        i++;
    }
    return true;
}
 
 
bool file_parser::is_opcode(string line)
{
    return true;
}
 
 
bool file_parser::is_operand(string line)
{
    return true;
}
 
 
bool file_parser::is_comment(string line)
{
    if (line[0] == '.')
 
    {
        return true;
    }
    return false;
}
 
 
/*Probably not needed*/
bool file_parser::is_apostrophe(string line)
{
    int i = 0;
    while (line[i] != '\0')
    {
        if (line[i] == '\'')
        {
            if (DEBUG)
            {
                cout << "Working properly detecting: " << '\'' << endl;
            }
            return true;
        }
        i++;
    }
    return false;
}
 
 
string file_parser::get_token(unsigned int line, unsigned int field)
{
    line--;
    if (line<(unsigned)file_size && line>= 0)
 
    {
        if (DEBUG)
        {
            cout << endl;
            cout<< "DEBUG: label is: " << v[line].label << "::" <<
                "DEBUG: opcode is: " << v[line].opcode << "::" <<
                "DEBUG: operand is: " << v[line].operand << "::" << endl;
            cout << "DEBUG: comment is: " << v[line].comment << "::" << endl;
            cout << "DEBUG: line is: " << int_to_string(line) << "::" <<
                 "DEBUG: file_size is: " << int_to_string((unsigned)file_size) << "::" <<
                 "DEBUG: Field is: " << int_to_string(field) << "::" << endl;
        }
        switch (field)
        {
        case 0:
            return  v[line].label;
            break;
        case 1:
            return  v[line].opcode;
            break;
        case 2:
            return v[line].operand;
            break;
        case 3:
            return v[line].comment;
            break;
        default:
            throw file_parse_exception("Invalid field");
            break;
        }
    }
    else
        throw file_parse_exception("Invalid line");
    return 0;
}
 
 
string  file_parser::int_to_string(int n)
{
    ostringstream outstr;
    outstr << n;
    return outstr.str();
}
 
 
void file_parser::print_file()
{
    if (DEBUG)
    {
        cout<< endl;
        cout<< "Print File Begin test: " << endl;
    }
    for (int i=0; i<file_size; i++)
 
    {
        cout << left << setw(18) << v[i].label
             << left << setw(18) << v[i].opcode
             << left << setw(18) << v[i].operand
             << left << v[i].comment << endl;
    }
}
 
 
int file_parser::size()
{
    return file_size;
}
 
void file_parser::prnt(string s)
{
    cout << s << endl;
}
